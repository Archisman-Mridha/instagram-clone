// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: queries.sql

package sql_generated

import (
	"context"
)

const deleteRowsWithPublishedMessages = `-- name: DeleteRowsWithPublishedMessages :exec
DELETE FROM outbox
  WHERE published=TRUE
`

func (q *Queries) DeleteRowsWithPublishedMessages(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteRowsWithPublishedMessages)
	return err
}

const getUnpublishedMessages = `-- name: GetUnpublishedMessages :many
WITH selected_rows AS (
  SELECT id FROM outbox
    WHERE locked=FALSE AND published=FALSE
    LIMIT $1
      FOR UPDATE SKIP LOCKED
)
  UPDATE outbox
    SET locked=TRUE, locked_on=CURRENT_TIMESTAMP
      WHERE (id) IN (SELECT id from selected_rows)
        RETURNING id, message
`

type GetUnpublishedMessagesRow struct {
	ID      int32
	Message []byte
}

func (q *Queries) GetUnpublishedMessages(ctx context.Context, batchSize int32) ([]GetUnpublishedMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getUnpublishedMessages, batchSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnpublishedMessagesRow
	for rows.Next() {
		var i GetUnpublishedMessagesRow
		if err := rows.Scan(&i.ID, &i.Message); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertMessage = `-- name: InsertMessage :exec
INSERT INTO outbox
  (message)
    VALUES ($1)
`

func (q *Queries) InsertMessage(ctx context.Context, message []byte) error {
	_, err := q.db.ExecContext(ctx, insertMessage, message)
	return err
}

const unlockMessagesFailedTobePublished = `-- name: UnlockMessagesFailedTobePublished :exec
UPDATE outbox
  SET locked=FALSE, locked_on=NULL
    WHERE id = $1
`

func (q *Queries) UnlockMessagesFailedTobePublished(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, unlockMessagesFailedTobePublished, id)
	return err
}
